import { program } from "commander";
import SystemParameters, * as config from "./config/config.js";
import { handleAnalysisAction } from "./handlers/analyses.js";
import { handleRepositoryAction } from "./handlers/repositories.js";
import handleSnapshotAction from "./handlers/snapshots.js";
import handleToolsAction from "./handlers/tools.js";
import { AnalysesCommandSchema, RepoCommandSchema, SnapshotCommandSchema } from "./types/schemas.js";
import { ZodError } from "zod";
import handleInvalidCommand from "./utils/handleInvalidCommand.js";
import { COMMAND_ACTIONS } from "./utils/constants.js";
program
    .name("testmachine")
    .description("TestMachine AI's CLI. Analyze smart contracts.")
    .version(config.CLI_VERSION)
    .option("-v|--verbose", "Enable verbose logging.")
    .option("-o|--output <outputFormat>", "Set result output type. Currently supported formats: json")
    .option("-t|--token <tokenOrTokenPath>", "The API token to use. This can be either a file path or a string")
    .on("option:token", (tokenOrTokenPath) => {
    // A set environment variable takes precedence.
    process.env[config.TOKEN_KEY] ??= tokenOrTokenPath;
})
    .on("option:output", (outputFormat) => {
    if (outputFormat.toUpperCase() === "JSON")
        SystemParameters.getInstance().enableJsonOutput();
});
program
    .command("repo")
    .description("Manage repositories.")
    .argument(`<action>", "The action to perform. Must be in [${COMMAND_ACTIONS.LIST}, ${COMMAND_ACTIONS.CREATE}].`)
    .option("--name <name>", "The name of the repository to create.")
    .action(async (action, options) => {
    try {
        const { action: verifiedAction, options: verifiedOptions } = RepoCommandSchema.parse({ action, options });
        handleRepositoryAction(verifiedAction, verifiedOptions.name);
    }
    catch (e) {
        if (e instanceof ZodError) {
            return handleInvalidCommand(e);
        }
        else {
            throw e;
        }
    }
});
program
    .command("snapshot")
    .description("Manage snapshots.")
    .argument("<action>", `The action to perform. Must be in [${COMMAND_ACTIONS.LIST}, ${COMMAND_ACTIONS.CREATE}, ${COMMAND_ACTIONS.ANALYZE}, ${COMMAND_ACTIONS.SCAN}].`)
    .option("--repo-id <id>", "The ID of the repository to create this snapshot under - get this from `repo list`.")
    .option("--snapshot-id <id>", "The ID of the snapshot - get this from `snapshot list`.")
    .option("--tools <tools...>", "List of tools to run.")
    .option("--file <path...>", "The file to upload for a new snapshot.")
    .option("--partial", "An option to perform analyses only in a subset of files")
    .action(async (action, options) => {
    try {
        const { action: verifiedAction, options: { file, repoId, snapshotId, tools, partial } } = SnapshotCommandSchema.parse({ action, options });
        await handleSnapshotAction(verifiedAction, repoId, snapshotId, file, tools, partial);
    }
    catch (e) {
        if (e instanceof ZodError) {
            return handleInvalidCommand(e);
        }
        else {
            throw e;
        }
    }
});
program
    .command("analyses")
    .description("Manage analyses.")
    .argument("<action>", `The action to perform. Must be in [${COMMAND_ACTIONS.LIST}, ${COMMAND_ACTIONS.GET}, ${COMMAND_ACTIONS.REPORT}, ${COMMAND_ACTIONS.PROGRESS}].`)
    .option("--snapshot-id <id>", "The ID of the snapshot to analyze - get this from `snapshot list`.")
    .option("--analysis-id <id>", "The ID of the analysis - get this from `analyses list`.")
    .option("--analysis-request-id <id>", "The ID of the analysis request`.")
    .action(async (action, options) => {
    try {
        const { action: verifiedAction, options: { analysisId, snapshotId, analysisRequestId } } = AnalysesCommandSchema.parse({ action, options });
        await handleAnalysisAction(verifiedAction, snapshotId, analysisId, analysisRequestId);
    }
    catch (e) {
        if (e instanceof ZodError) {
            return handleInvalidCommand(e);
        }
        else {
            throw e;
        }
    }
});
program
    .command("tools")
    .description("Query available tools")
    .argument(`<action>", "The action to perform. Must be in [${COMMAND_ACTIONS.LIST}].`)
    .action(async (action) => {
    handleToolsAction(action);
});
export default program;
