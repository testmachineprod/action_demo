import axios from "axios";
import chalk from "chalk";
import FormData from "form-data";
import fs from "fs";
import inquirer from "inquirer";
import getAPI from "../config/api.js";
import SystemParameters from "../config/config.js";
import { ToolNames } from "../config/constants.js";
import { zipDirectory } from "../utils/getDirectoryFiles.js";
import getSpinner from "../utils/getSpinner.js";
import getUniqueId from "../utils/getUniqueId.js";
import handleError from "../utils/handleError.js";
import { CreateAnalysisSchema, CreateRepositorySnapshotSchema, ListRepositorySnapshotsSchema, ListSnapshotFilesSchema } from "../types/schemas.js";
import getAnalysisTools from "../utils/getAnalysisTools.js";
import { COMMAND_ACTIONS } from "../utils/constants.js";
import { ColumnAlignment, generateOutputTable } from "../utils/ttyOutputHelper.js";
async function promptForCategories(api) {
    const response = await api.get(`/analyses/vulns`);
    const { categories } = response.data;
    const reply = await inquirer.prompt({
        name: "category",
        type: "checkbox",
        message: "Select vulnerability categories to help focus the AI",
        loop: false,
        choices: Object.values(categories).map((cat) => cat.name)
    });
    const selectedNames = reply["category"];
    const catSlugs = Object.values(categories)
        .filter((cat) => selectedNames.includes(cat.name))
        .map((cat) => cat.slug);
    return catSlugs;
}
async function promptSelectFiles(api, snapshotId) {
    const response = await api.get(`/snapshots/${snapshotId}/files`);
    const parsedResponse = ListSnapshotFilesSchema.safeParse(response.data);
    if (!parsedResponse.success) {
        return handleError({
            error: {
                message: "Invalid response from API"
            }
        });
    }
    const { files } = parsedResponse.data;
    const reply = await inquirer.prompt({
        name: "files",
        type: "checkbox",
        message: "Select the files to analyze",
        loop: false,
        choices: files.map((file) => file.path)
    });
    const selectedFilePaths = reply["files"];
    const selectedFiles = files.filter((file) => selectedFilePaths.includes(file.path));
    return selectedFiles;
}
export default async function handleSnapshotAction(action, repoId, snapshotId, filepaths, tools, partial) {
    const api = await getAPI();
    if (repoId)
        repoId = parseInt(repoId.toString());
    if (snapshotId)
        snapshotId = parseInt(snapshotId.toString());
    switch (action) {
        case COMMAND_ACTIONS.LIST:
            return listSnapshots(api, repoId);
        case COMMAND_ACTIONS.CREATE:
            return createSnapshot(api, repoId, filepaths);
        case COMMAND_ACTIONS.ANALYZE:
            return analyzeSnapshot(api, snapshotId, tools, partial, !tools || tools.includes(ToolNames.AI)
                ? await promptForCategories(api)
                : []);
        case COMMAND_ACTIONS.SCAN:
            return createSnapshot(api, repoId, filepaths, tools);
        default:
            handleError({
                error: {
                    message: `Invalid action: [${action}] must be in [${COMMAND_ACTIONS.LIST}, ${COMMAND_ACTIONS.CREATE}, ${COMMAND_ACTIONS.ANALYZE}, ${COMMAND_ACTIONS.SCAN}].`
                }
            });
    }
}
async function analyzeSnapshot(api, snapshotId, tools, partial, categories) {
    if (!snapshotId)
        return handleError({ error: { message: "Missing snapshot ID." } });
    const analysisTools = await getAnalysisTools(api);
    const toolNames = analysisTools.map((tool) => tool.name);
    validateTools(tools, toolNames);
    const filesToAnalyze = partial
        ? await promptSelectFiles(api, snapshotId)
        : undefined;
    const spinner = getSpinner("Analyzing snapshot...");
    let response;
    let analysisRequest;
    const skippedTools = [];
    const fileIds = filesToAnalyze
        ? filesToAnalyze
            .map((file) => file.metadataFileId ? [file.id, file.metadataFileId] : [file.id])
            .flat()
        : [];
    try {
        response = await api.post(`/snapshots/${snapshotId}/analyses`, {
            tools,
            categories,
            fileIds: fileIds
        });
        const parsedResponse = CreateAnalysisSchema.safeParse(response.data);
        if (!parsedResponse.success) {
            return handleError({
                error: {
                    message: "Invalid response from API"
                }
            });
        }
        analysisRequest = parsedResponse.data.analysisRequest;
        skippedTools.push(...parsedResponse.data.skippedTools);
    }
    catch (processError) {
        if (axios.isAxiosError(processError)) {
            return handleError({
                response: processError.response
            });
        }
        else {
            return handleError({
                error: {
                    message: processError.message
                }
            });
        }
    }
    finally {
        spinner.stop();
    }
    if (!analysisRequest.id || !analysisRequest.createdAt) {
        return handleError({
            error: {
                message: "Analysis could not be created."
            }
        });
    }
    if (!analysisRequest.analyses.length) {
        return handleError({
            error: {
                message: "Analysis request did not create analyses results."
            }
        });
    }
    if (SystemParameters.getInstance().isJsonOutput()) {
        console.log(JSON.stringify(analysisRequest));
    }
    else {
        console.log(chalk.green(`Analysis created:`));
        const result = analysisRequest.analyses.map((analysis) => {
            return [
                analysisRequest.id,
                analysis.id,
                analysis.requestedAt,
                analysis.tool.name,
                analysis.error ? analysis.error : "",
                analysis.status
            ];
        });
        const columnAttributes = [
            {
                headerLabel: "Request Id",
                alignment: ColumnAlignment.Center
            },
            {
                headerLabel: "Analysis Id",
                alignment: ColumnAlignment.Center
            },
            {
                headerLabel: "Requested at"
            },
            {
                headerLabel: "Tool"
            },
            {
                headerLabel: "Error"
            },
            {
                headerLabel: "Status"
            }
        ];
        console.table(generateOutputTable(columnAttributes, result));
    }
    if (skippedTools.length > 0) {
        const formattedSkippedTools = skippedTools.map((tool) => `'${tool}'`);
        const skippedToolsString = formattedSkippedTools.length === 1
            ? formattedSkippedTools[0]
            : `${skippedTools.slice(0, -1).join(",")} and ${skippedTools.at(-1)}`;
        console.log(chalk.yellow(`\n\nNote:
    Skipped ${skippedToolsString} analyses. Please compile your project and upload metadata as JSON.
    See: https://testmachine.ai/docs for more information`));
    }
}
async function createSnapshot(api, repoId, filepaths, toolsToRunAfterCreated = []) {
    if (!repoId)
        return handleError({ error: { message: "Missing repository ID." } });
    if (!filepaths || !filepaths.length)
        return handleError({ error: { message: "Missing file path." } });
    if (filepaths.some((filepath) => !fs.existsSync(filepath)))
        return handleError({ error: { message: "File does not exist." } });
    const directories = filepaths.filter((filepath) => fs.lstatSync(filepath).isDirectory());
    const spinner = getSpinner("Uploading file...");
    const files = [];
    for (const directory of directories) {
        files.push({
            name: `${getUniqueId()}.zip`,
            path: "/",
            stream: zipDirectory(directory)
        });
    }
    for (const filepath of filepaths) {
        if (!directories.includes(filepath)) {
            files.push({
                name: filepath.split("/").slice(-1)[0],
                path: "",
                stream: fs.createReadStream(filepath)
            });
        }
    }
    const formData = new FormData();
    for (const { stream: fileStream } of files) {
        formData.append("files", fileStream);
    }
    let response;
    let snapshot;
    try {
        response = await api.post(`/repositories/${repoId}/snapshots`, formData);
        const parsedResponse = CreateRepositorySnapshotSchema.safeParse(response.data);
        if (!parsedResponse.success) {
            return handleError({
                error: {
                    message: "Invalid response from API"
                }
            });
        }
        snapshot = parsedResponse.data;
    }
    catch (processError) {
        if (axios.isAxiosError(processError)) {
            return handleError({
                response: processError.response
            });
        }
        else {
            return handleError({
                error: {
                    message: processError.message
                }
            });
        }
    }
    finally {
        spinner.stop();
    }
    if (SystemParameters.getInstance().isJsonOutput()) {
        console.log(JSON.stringify({ ID: snapshot.id }));
    }
    else {
        const result = [[snapshot.id]];
        console.log(chalk.green(`\nSnapshot created:`));
        const columnAttributes = [
            {
                headerLabel: "Id",
                alignment: ColumnAlignment.Center
            }
        ];
        console.table(generateOutputTable(columnAttributes, result));
    }
    if (toolsToRunAfterCreated.length) {
        let categories = [];
        if (toolsToRunAfterCreated.includes(ToolNames.AI)) {
            categories = await promptForCategories(api);
        }
        return analyzeSnapshot(api, snapshot.id, toolsToRunAfterCreated, false, categories);
    }
}
async function listSnapshots(api, repoId) {
    if (!repoId)
        return handleError({ error: { message: "Missing repository ID." } });
    const spinner = getSpinner("Retrieving snapshots...");
    let response;
    let snapshotsList;
    try {
        response = await api.get(`/repositories/${repoId}/snapshots`);
        const parsedResponse = ListRepositorySnapshotsSchema.safeParse(response.data);
        if (!parsedResponse.success) {
            return handleError({
                error: {
                    message: "Invalid response from API"
                }
            });
        }
        snapshotsList = parsedResponse.data.snapshots;
    }
    catch (processError) {
        if (axios.isAxiosError(processError)) {
            return handleError({
                response: processError.response
            });
        }
        else {
            return handleError({
                error: {
                    message: processError.message
                }
            });
        }
    }
    finally {
        spinner.stop();
    }
    if (SystemParameters.getInstance().isJsonOutput()) {
        console.log(JSON.stringify(snapshotsList));
    }
    else {
        console.log(chalk.green(`\nSnapshots:`));
        const result = snapshotsList.map((snapshot) => {
            return [
                snapshot.id,
                snapshot.createdAt,
                snapshot._count.files ?? 0,
                snapshot._count.analyses ?? 0
            ];
        });
        const columnAttributes = [
            {
                headerLabel: "Id",
                alignment: ColumnAlignment.Center
            },
            {
                headerLabel: "Created at"
            },
            {
                headerLabel: "# files",
                alignment: ColumnAlignment.Center
            },
            {
                headerLabel: "# analyses",
                alignment: ColumnAlignment.Center
            }
        ];
        console.table(generateOutputTable(columnAttributes, result));
    }
}
function validateTools(tools, validTools) {
    if (tools) {
        const invalidTools = tools.filter((tool) => !validTools.includes(tool));
        if (invalidTools.length) {
            return handleError({
                error: { message: `Invalid tool: ${invalidTools.join(",")}` }
            });
        }
    }
}
